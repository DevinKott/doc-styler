---
import Layout from '../layouts/Layout.astro';

const placeholderText: string = "Welcome!\n\nTo get started, start replacing this text.\nThe bottom text area will automatically update as you type.";
---

<Layout title="DocStyler">
	<main class="m-auto p-4 leading-relaxed text-xl text-white max-w-[calc(100%_-_2rem)] w-4/5 flex flex-col">
		<span class="text-6xl font-bold text-center my-4 py-4">
			DocStyler
		</span>
		<div class="flex justify-center mb-4">
			<textarea
				id="input-doc"
				class="w-3/5 p-2 border rounded-lg text-black"
				placeholder={placeholderText}
			></textarea>
		</div>
		<div class="flex justify-center">
			<textarea
				id="output-doc"
				class="w-3/5 p-2 border rounded-lg text-black"
				disabled
			></textarea>
		</div>
	</main>
</Layout>
<script>
	const inputDocArea = document.getElementById("input-doc");
	const outputDocArea = document.getElementById("output-doc");

	// *****************************************************************************
	// *                      Transform Documentation Function                     *
	// *                                                                           *
	// *  This function will take an input string and output the formatted docume  *
	// *    ntation, given the max width, padding, initial comment, and border.    *
	// *****************************************************************************
	const transformDocumentation = (input: string, maxWidth: number, padding: number) => {
		let comment = "// ";
		let border = "*";

		let output: string = "";
		let lines = input.split("\n").map(s => s.trim());
		console.log(lines)


		// *****************************************************************************
		// *                             Create Top Border                             *
		// *****************************************************************************
		let remainingWidth = maxWidth;

		output += comment; // Add the comment
		remainingWidth -= comment.length;

		while (remainingWidth > 0) {
			output += border;
			remainingWidth -= border.length;
		}

		output += "\n";


		// *****************************************************************************
		// *                            Preprocess Each Line                           *
		// *                                                                           *
		// *   This section will ensure that each line in the input is capped to the   *
		// *                          maximum available space.                         *
		// *    If there are longer lines, they are cut continuously by the maximum    *
		// *                       available space until they fit.                     *
		// *                         Full words are preserved.                         *
		// *****************************************************************************
		let maxTextWidth = maxWidth - comment.length - (border.length * 2) - (padding * 2);
		let preprocessedLines: string[] = [];
		for (let i = 0; i < lines.length; i += 1) {
			let line: string = lines[i];
			if (line.length <= maxTextWidth) {
				preprocessedLines.push(line);
			} else {
				let tempLine: string = line;
				while (tempLine.length > maxTextWidth) {
					let cut = maxTextWidth;
					let didCut = true;
					while (tempLine.at(cut) != " " && cut >= 0) {
						cut -= 1;
					}

					if (cut < 0) {
						cut = maxTextWidth;
						didCut = false;
					}

					let cutLine: string = tempLine.substring(0, cut);
					preprocessedLines.push(cutLine);

					tempLine = tempLine.substring(cut);
				}

				if (tempLine.length > 0) {
					preprocessedLines.push(tempLine);
				}
			}
		}

		lines = preprocessedLines;


		// *****************************************************************************
		// *                          Create Each Output Line                          *
		// *                                                                           *
		// *   Each line is taken and the maximum allowed text length is calculated.   *
		// *    The final "centered text" is then continuously grown on each side to   *
		// *             contain spaces until the allowed text length is 0.            *
		// *****************************************************************************
		for (let i = 0; i < lines.length; i += 1) {
			let line: string = lines[i];

			remainingWidth = maxWidth; // Reset remaining width available

			output += comment; // Add the comment, subtract from remaining width
			remainingWidth -= comment.length;

			output += border; // Add the border, subtract from remaining width
			remainingWidth -= border.length;

			// Add first padding
			for (let j = 0; j < padding; j += 1) {
				output += " ";
				remainingWidth -= 1;
			}

			// Need to save room for the remaining padding and the border
			let availableTextWidth = remainingWidth - padding - border.length - line.length;

			// Generate the spaces + text to place down
			let outputLine: string = line;
			while (availableTextWidth > 0) {
				outputLine = " " + outputLine + " ";
				availableTextWidth -= 2;
			}

			output += outputLine;
			if (line.length % 2 == 0) {
				output = output.substring(0, output.length - 1);
			}


			// Add second padding
			for (let j = 0; j < padding; j += 1) {
				output += " ";
			}

			// Add border
			output += border;

			output += "\n"
		}

		// *****************************************************************************
		// *                             Create Bottom Border                          *
		// *****************************************************************************
		remainingWidth = maxWidth;

		output += comment; // Add the comment
		remainingWidth -= comment.length;

		while (remainingWidth > 0) {
			output += border;
			remainingWidth -= border.length;
		}

		console.log(output)
		return output;
	};
	
	inputDocArea?.addEventListener(
		"input",
		(e: Event) => {
			const target: HTMLTextAreaElement = e.target as HTMLTextAreaElement;
			const outputTextArea: HTMLTextAreaElement = outputDocArea as HTMLTextAreaElement;

			outputTextArea.value = transformDocumentation(target.value, 80, 2);

			target.style.height = 'auto';
			target.style.height = `${target.scrollHeight}px`;

			outputTextArea.style.height = 'auto';
			outputTextArea.style.height = `${outputTextArea.scrollHeight}px`;
		}
	);

	// Override tab to insert 4 spaces
	inputDocArea?.addEventListener(
		"keydown",
		(keyboardEvent) => {
			if (keyboardEvent.key === 'Tab')
			{
				keyboardEvent.preventDefault();
				let target = keyboardEvent.target as HTMLTextAreaElement;
				target.value += "    ";
				console.log("tab")
			}
		}
	);
</script>
